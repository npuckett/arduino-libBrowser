<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Arduino Library</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">
                THE ARDUINO LIBRARY
                <span class="subtitle">A snapshot of 8,000+ libraries from GitHub as of July 21, 2025</span>
            </div>
        </div>

        <div class="about-section">
            <div class="section-header collapsible" id="aboutHeader">
                About
                <span class="collapse-indicator">+</span>
            </div>
            <div class="about-content collapsed" id="aboutContent">
                <p><a href="https://github.com/npuckett/arduino-libBrowser" target="_blank" rel="noopener">The Arduino Library</a> is an open source tool created to help people discover the wide range of libraries being developed on the Arduino platform. It was created by <a href="https://github.com/npuckett" target="_blank" rel="noopener">Nick Puckett</a>.</p>
            </div>
        </div>

        <div class="search-container">
            <div class="section-header">
                Search
                <button class="clear-search-btn" id="clearSearchBtn" style="display: none;" title="Clear search">×</button>
            </div>
            <input 
                type="text" 
                class="search-box" 
                placeholder="Search the collection by title, description, author, or subject..."
                id="searchInput"
            >
            <div class="search-nav" id="searchNav" style="display: none;">
                <div class="search-nav-title">Jump to:</div>
                <div class="search-nav-links" id="searchNavLinks">
                    <!-- Navigation links will be dynamically generated here -->
                </div>
            </div>
        </div>

        <!-- <div class="random-pick-section">
            <div class="section-header">
                Grab Bag Selection
            </div>
            <div class="random-pick-card" id="randomPick">
                <div class="loading">Selecting a random library...</div>
            </div>
        </div> -->

        <div class="browse-section">
            <div class="section-header">Browse</div>
            <div class="sort-buttons">
                <button class="sort-btn" data-sort="alphabetical">Alphabetical (A-Z)</button>
                <button class="sort-btn" data-sort="alphabetical-reverse">Alphabetical (Z-A)</button>
                <button class="sort-btn active" data-sort="most-recent">Most Recent</button>
                <button class="sort-btn" data-sort="least-recent">Least Recent</button>
                <button class="sort-btn" data-sort="most-popular">Most Popular (Stars)</button>
                <button class="sort-btn" data-sort="shelf-order">Registry Order</button>
                <button class="sort-btn" data-sort="heavily-relied">Heavily Relied</button>
            </div>
            
            <div class="category-filters" id="categoryFilters">
                <div class="section-header collapsible" id="categoryHeader">
                    Browse By Subject
                    <span class="collapse-indicator">+</span>
                </div>
                <div class="filter-buttons collapsed" id="filterButtons">
                    <button class="filter-btn active" data-category="all">All</button>
                </div>
            </div>

            <div class="platform-filters" id="platformFilters">
                <div class="section-header collapsible" id="platformHeader">
                    Browse by Platform
                    <span class="collapse-indicator">+</span>
                </div>
                <div class="filter-buttons collapsed" id="platformButtons">
                    <button class="filter-btn active" data-platform="all">All Platforms</button>
                </div>
            </div>
        </div>

        <div class="loading" id="loading">
            Loading collection...
        </div>

        <div class="library-grid" id="libraryGrid" style="display: none;">
        </div>

        <div class="no-results" id="noResults" style="display: none;">
            No items found in the collection matching your search.
        </div>
    </div>

    <!-- Library Detail Modal -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content">
            <div class="modal-header">
                <button class="modal-close" id="modalClose">×</button>
                <div class="modal-title" id="modalTitle">Library Details</div>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        let libraries = [];
        let filteredLibraries = [];
        let currentCategory = 'all';
        let currentPlatform = 'all';
        let currentSearchQuery = '';
        let currentSort = 'most-recent';

        // Load the library data
        async function loadLibraries() {
            try {
                const response = await fetch('output/libraries.json');
                const data = await response.json();
                libraries = data.libraries;
                filteredLibraries = libraries;
                
                // Update header with dynamic information
                updateHeaderInfo(data);
                
                populateCategoryFilters();
                populatePlatformFilters();
                setupSortButtons();
                // displayRandomPick();
                applyFilters();
                document.getElementById('loading').style.display = 'none';
                document.getElementById('libraryGrid').style.display = 'grid';
            } catch (error) {
                document.getElementById('loading').textContent = 'Error loading collection. Make sure libraries.json is accessible.';
                console.error('Error loading libraries:', error);
            }
        }

        // Update header with dynamic library count and last update
        function updateHeaderInfo(data) {
            const subtitle = document.querySelector('.subtitle');
            const libraryCount = data.libraries.length;
            const lastUpdate = data.enhanced_at || data.processed_at || '2025-07-21';
            const formattedDate = formatDateForHeader(lastUpdate);
            subtitle.textContent = `${libraryCount.toLocaleString()} entries, updated ${formattedDate}`;
        }

        // Format date for header display
        function formatDateForHeader(dateString) {
            if (!dateString) return 'recently';
            try {
                const date = new Date(dateString);
                const options = { month: 'long', day: 'numeric', year: 'numeric' };
                return date.toLocaleDateString('en-US', options);
            } catch (error) {
                return 'recently';
            }
        }

        // Populate platform filter buttons
        function populatePlatformFilters() {
            // Get all unique architectures
            const allArchs = new Set();
            libraries.forEach(lib => {
                const archs = (lib.architectures || '*').split(',').map(a => a.trim());
                archs.forEach(arch => {
                    if (arch && arch !== '*') {
                        allArchs.add(arch);
                    }
                });
            });
            
            const platforms = Array.from(allArchs).sort();
            const platformButtons = document.getElementById('platformButtons');
            
            // Keep the "All Platforms" button and add platform buttons
            const allButton = platformButtons.querySelector('[data-platform="all"]');
            platformButtons.innerHTML = '';
            platformButtons.appendChild(allButton);
            
            // Add common platforms first
            const commonPlatforms = ['avr', 'esp32', 'esp8266', 'samd', 'arm', 'arduino'];
            commonPlatforms.forEach(platform => {
                if (platforms.includes(platform)) {
                    const button = document.createElement('button');
                    button.className = 'filter-btn';
                    button.setAttribute('data-platform', platform);
                    button.textContent = platform.toUpperCase();
                    platformButtons.appendChild(button);
                }
            });
            
            // Add remaining platforms
            platforms.forEach(platform => {
                if (!commonPlatforms.includes(platform)) {
                    const button = document.createElement('button');
                    button.className = 'filter-btn';
                    button.setAttribute('data-platform', platform);
                    button.textContent = platform.toUpperCase();
                    platformButtons.appendChild(button);
                }
            });
            
            // Add event listeners to platform filter buttons
            platformButtons.addEventListener('click', (e) => {
                if (e.target.classList.contains('filter-btn')) {
                    const clickedPlatform = e.target.getAttribute('data-platform');
                    
                    // If clicking the currently active filter (and it's not "all"), deselect it
                    if (currentPlatform === clickedPlatform && clickedPlatform !== 'all') {
                        // Reset to "all"
                        currentPlatform = 'all';
                        platformButtons.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                        document.querySelector('[data-platform="all"]').classList.add('active');
                    } else {
                        // Update active state normally
                        platformButtons.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');
                        currentPlatform = clickedPlatform;
                    }
                    
                    applyFilters();
                }
            });
        }

        // Filter libraries by author
        function filterByAuthor(authorName) {
            // Set search query to author name  
            currentSearchQuery = authorName;
            document.getElementById('searchInput').value = authorName;
            
            // Show clear search button
            const clearBtn = document.getElementById('clearSearchBtn');
            clearBtn.style.display = 'block';
            
            // Reset other filters to show all categories/platforms for this author
            currentCategory = 'all';
            currentPlatform = 'all';
            
            // Update filter button states
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector('[data-category="all"]').classList.add('active');
            document.querySelector('[data-platform="all"]').classList.add('active');
            
            // Apply author-specific search that only shows author matches
            applyAuthorFilter(authorName);
            
            // Scroll to top of results
            document.getElementById('libraryGrid').scrollIntoView({ behavior: 'smooth' });
        }
        
        // Apply author-specific filter (shows only author matches)
        function applyAuthorFilter(authorName) {
            const authorMatches = libraries.filter(lib => 
                (lib.author || '').toLowerCase().includes(authorName.toLowerCase())
            );
            
            // Sort the author matches
            const sortedMatches = sortLibraries(authorMatches);
            
            filteredLibraries = sortedMatches;
            updateActiveFiltersDisplay();
            
            // Display as author group only
            displayAuthorOnlyResults(sortedMatches, authorName);
        }
        
        // Display results showing only author matches
        function displayAuthorOnlyResults(libraries, authorName) {
            const grid = document.getElementById('libraryGrid');
            const noResults = document.getElementById('noResults');
            
            if (libraries.length === 0) {
                grid.style.display = 'none';
                noResults.style.display = 'block';
                return;
            }

            noResults.style.display = 'none';
            grid.style.display = 'block';
            
            // Display as a single author group
            const html = `<div class="search-group">
                <div class="search-group-header">Libraries by ${escapeHtml(authorName)} (${libraries.length})</div>
                <div class="search-group-grid">${libraries.map(lib => createLibraryCard(lib)).join('')}</div>
            </div>`;
            
            grid.innerHTML = html;
        }

        // Update the active filters display
        function updateActiveFiltersDisplay() {
            // Since we removed the alphabet navigation section, 
            // this function no longer needs to display anything
            // but we keep it to avoid breaking other code that calls it
        }

        function setupSortButtons() {
            const sortButtons = document.querySelector('.sort-buttons');
            sortButtons.addEventListener('click', (e) => {
                if (e.target.classList.contains('sort-btn')) {
                    // Clear all filters when using browse buttons to show full collection
                    const searchInput = document.getElementById('searchInput');
                    searchInput.value = '';
                    currentSearchQuery = '';
                    currentCategory = 'all';
                    currentPlatform = 'all';
                    
                    // Reset all filter button states
                    document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                    document.querySelector('[data-category="all"]').classList.add('active');
                    document.querySelector('[data-platform="all"]').classList.add('active');
                    
                    // Update active state for sort buttons
                    sortButtons.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // Update current sort and apply
                    currentSort = e.target.getAttribute('data-sort');
                    applyFilters();
                }
            });
        }

        // Sort libraries based on current sort method
        function sortLibraries(libraries) {
            const sorted = [...libraries];
            
            switch (currentSort) {
                case 'alphabetical':
                    return sorted.sort((a, b) => a.name.localeCompare(b.name));
                
                case 'alphabetical-reverse':
                    return sorted.sort((a, b) => b.name.localeCompare(a.name));
                
                case 'most-recent':
                    // Sort by GitHub updated_at date (most recent first)
                    return sorted.sort((a, b) => {
                        const dateA = new Date(a.github_updated_at || a.processed_at || '1900-01-01');
                        const dateB = new Date(b.github_updated_at || b.processed_at || '1900-01-01');
                        return dateB - dateA; // Most recent first
                    });
                
                case 'least-recent':
                    // Sort by GitHub updated_at date (oldest first)
                    return sorted.sort((a, b) => {
                        const dateA = new Date(a.github_updated_at || a.processed_at || '1900-01-01');
                        const dateB = new Date(b.github_updated_at || b.processed_at || '1900-01-01');
                        return dateA - dateB; // Oldest first
                    });
                
                case 'most-popular':
                    // Sort by GitHub stars (most stars first)
                    return sorted.sort((a, b) => {
                        const starsA = parseInt(a.github_stars) || 0;
                        const starsB = parseInt(b.github_stars) || 0;
                        if (starsB !== starsA) return starsB - starsA; // Most stars first
                        return a.name.localeCompare(b.name); // Secondary sort by name
                    });
                
                case 'shelf-order':
                    // Random arrangement like finding misplaced books
                    // Use a seeded random based on current time to get different results each click
                    const shuffled = [...sorted];
                    for (let i = shuffled.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                    }
                    return shuffled;
                
                case 'heavily-relied':
                    // Sort by number of dependencies (more dependencies = heavily relied upon by others)
                    return sorted.sort((a, b) => {
                        const depsA = (a.depends || '').split(',').filter(d => d.trim()).length;
                        const depsB = (b.depends || '').split(',').filter(d => d.trim()).length;
                        if (depsB !== depsA) return depsB - depsA;
                        return a.name.localeCompare(b.name); // Secondary sort
                    });
                
                default:
                    return sorted;
            }
        }

        // Populate category filter buttons
        function populateCategoryFilters() {
            const categories = [...new Set(libraries.map(lib => lib.category))].sort();
            const filterButtons = document.getElementById('filterButtons');
            
            // Keep the "All" button and add category buttons
            const allButton = filterButtons.querySelector('[data-category="all"]');
            filterButtons.innerHTML = '';
            filterButtons.appendChild(allButton);
            
            categories.forEach(category => {
                if (category && category !== 'Uncategorized') {
                    const button = document.createElement('button');
                    button.className = 'filter-btn';
                    button.setAttribute('data-category', category);
                    button.textContent = category;
                    filterButtons.appendChild(button);
                }
            });
            
            // Add uncategorized at the end if it exists
            if (categories.includes('Uncategorized')) {
                const button = document.createElement('button');
                button.className = 'filter-btn';
                button.setAttribute('data-category', 'Uncategorized');
                button.textContent = 'Uncategorized';
                filterButtons.appendChild(button);
            }
            
            // Add event listeners to all filter buttons
            filterButtons.addEventListener('click', (e) => {
                if (e.target.classList.contains('filter-btn')) {
                    const clickedCategory = e.target.getAttribute('data-category');
                    
                    // If clicking the currently active filter (and it's not "all"), deselect it
                    if (currentCategory === clickedCategory && clickedCategory !== 'all') {
                        // Reset to "all"
                        currentCategory = 'all';
                        filterButtons.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                        document.querySelector('[data-category="all"]').classList.add('active');
                    } else {
                        // Update active state normally
                        filterButtons.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');
                        currentCategory = clickedCategory;
                    }
                    
                    applyFilters();
                }
            });
        }

        // Apply category, platform, search, and letter filters, then sort
        function applyFilters() {
            console.log('applyFilters called');
            console.log('Libraries array length:', libraries.length);
            console.log('Current search query:', currentSearchQuery);
            
            let filtered = libraries;
            
            // Apply category filter
            if (currentCategory !== 'all') {
                filtered = filtered.filter(lib => lib.category === currentCategory);
            }
            
            // Apply platform filter
            if (currentPlatform !== 'all') {
                filtered = filtered.filter(lib => {
                    const archs = (lib.architectures || '*').split(',').map(a => a.trim().toLowerCase());
                    return archs.includes('*') || archs.includes(currentPlatform.toLowerCase());
                });
            }

            // Apply search filter
            if (currentSearchQuery.trim()) {
                console.log('Applying search filter for:', currentSearchQuery);
                const searchTerms = currentSearchQuery.toLowerCase().split(' ').filter(term => term.length > 0);
                
                // Group results by match type
                const searchResults = {
                    nameMatches: [],
                    authorMatches: [],
                    categoryMatches: [],
                    descriptionMatches: []
                };
                
                libraries.forEach(lib => {
                    const name = (lib.name || '').toLowerCase();
                    const author = (lib.author || '').toLowerCase();
                    const category = (lib.category || '').toLowerCase();
                    const description = ((lib.sentence || '') + ' ' + (lib.paragraph || '')).toLowerCase();
                    
                    let hasMatch = false;
                    
                    // Check each search term
                    const matchesAllTerms = searchTerms.every(term => {
                        return name.includes(term) || author.includes(term) || 
                               category.includes(term) || description.includes(term);
                    });
                    
                    if (matchesAllTerms) {
                        // Determine primary match type (prioritize name > author > category > description)
                        if (searchTerms.some(term => name.includes(term))) {
                            searchResults.nameMatches.push(lib);
                        } else if (searchTerms.some(term => author.includes(term))) {
                            searchResults.authorMatches.push(lib);
                        } else if (searchTerms.some(term => category.includes(term))) {
                            searchResults.categoryMatches.push(lib);
                        } else {
                            searchResults.descriptionMatches.push(lib);
                        }
                    }
                });
                
                // Combine results in priority order
                filtered = [
                    ...searchResults.nameMatches,
                    ...searchResults.authorMatches,
                    ...searchResults.categoryMatches,
                    ...searchResults.descriptionMatches
                ];
                
                console.log('Search results breakdown:', {
                    name: searchResults.nameMatches.length,
                    author: searchResults.authorMatches.length,
                    category: searchResults.categoryMatches.length,
                    description: searchResults.descriptionMatches.length,
                    total: filtered.length
                });
            }
            
            // Apply sorting
            filtered = sortLibraries(filtered);
            
            filteredLibraries = filtered;
            updateActiveFiltersDisplay();
            displayLibraries(filteredLibraries.slice(0, 120));
        }

        // Display a random library pick
        function displayRandomPick() {
            if (libraries.length === 0) return;
            
            const randomLib = libraries[Math.floor(Math.random() * libraries.length)];
            const randomPickDiv = document.getElementById('randomPick');
            
            randomPickDiv.innerHTML = `
                <div class="random-pick-name">${escapeHtml(randomLib.name)}</div>
                <div class="random-pick-meta">Version ${escapeHtml(randomLib.version)} • ${escapeHtml(randomLib.author)}</div>
                <div class="random-pick-description">${escapeHtml(randomLib.sentence || randomLib.paragraph || 'A fascinating library waiting to be discovered.')}</div>
                <div class="random-pick-details">
                    <div class="random-pick-category">${escapeHtml(randomLib.category)}</div>
                    <div style="font-size: 11px; color: #666;">Repository: ${escapeHtml(randomLib.repository_name)}</div>
                </div>
            `;
        }

        // Get display name for sort method
        function getSortDisplayName(sortMethod) {
            switch (sortMethod) {
                case 'alphabetical': return 'Title (A-Z)';
                case 'alphabetical-reverse': return 'Title (Z-A)';
                case 'most-recent': return 'Most Recently Updated';
                case 'least-recent': return 'Least Recently Updated';
                case 'most-popular': return 'Popularity (Stars)';
                case 'shelf-order': return 'Random Arrangement';
                case 'heavily-relied': return 'Dependencies';
                default: return 'Unknown';
            }
        }

        // Display libraries in the grid
        function displayLibraries(librariesToShow) {
            const grid = document.getElementById('libraryGrid');
            const noResults = document.getElementById('noResults');
            
            if (librariesToShow.length === 0) {
                grid.style.display = 'none';
                noResults.style.display = 'block';
                return;
            }

            noResults.style.display = 'none';
            grid.style.display = 'grid';
            
            // If there's a search query, display grouped results
            if (currentSearchQuery.trim()) {
                displayGroupedSearchResults(librariesToShow);
            } else {
                // Regular grid display
                grid.innerHTML = librariesToShow.map((lib, index) => createLibraryCard(lib)).join('');
                // Hide search navigation when not searching
                updateSearchNavigation([]);
            }
        }
        
        // Display search results grouped by match type
        function displayGroupedSearchResults(libraries) {
            const grid = document.getElementById('libraryGrid');
            
            // Override grid display for search groups
            grid.style.display = 'block';
            
            const searchTerms = currentSearchQuery.toLowerCase().split(' ').filter(term => term.length > 0);
            
            // Group results by match type
            const groups = {
                nameMatches: [],
                authorMatches: [],
                categoryMatches: [],
                descriptionMatches: []
            };
            
            libraries.forEach(lib => {
                const name = (lib.name || '').toLowerCase();
                const author = (lib.author || '').toLowerCase();
                const category = (lib.category || '').toLowerCase();
                const description = ((lib.sentence || '') + ' ' + (lib.paragraph || '')).toLowerCase();
                
                // Check each match type independently - libraries can appear in multiple sections
                if (searchTerms.some(term => name.includes(term))) {
                    groups.nameMatches.push(lib);
                }
                if (searchTerms.some(term => author.includes(term))) {
                    groups.authorMatches.push(lib);
                }
                if (searchTerms.some(term => category.includes(term))) {
                    groups.categoryMatches.push(lib);
                }
                if (searchTerms.some(term => description.includes(term))) {
                    groups.descriptionMatches.push(lib);
                }
            });
            
            let html = '';
            let navLinks = [];
            
            // Add sections for each group that has results
            if (groups.nameMatches.length > 0) {
                html += `<div class="search-group" id="search-names">
                    <div class="search-group-header">Library Names (${groups.nameMatches.length})</div>
                    <div class="search-group-grid">${groups.nameMatches.map(lib => createLibraryCard(lib)).join('')}</div>
                </div>`;
                navLinks.push({ id: 'search-names', label: `Library Names (${groups.nameMatches.length})` });
            }
            
            if (groups.authorMatches.length > 0) {
                html += `<div class="search-group" id="search-authors">
                    <div class="search-group-header">Authors (${groups.authorMatches.length})</div>
                    <div class="search-group-grid">${groups.authorMatches.map(lib => createLibraryCard(lib)).join('')}</div>
                </div>`;
                navLinks.push({ id: 'search-authors', label: `Authors (${groups.authorMatches.length})` });
            }
            
            if (groups.categoryMatches.length > 0) {
                html += `<div class="search-group" id="search-categories">
                    <div class="search-group-header">Categories (${groups.categoryMatches.length})</div>
                    <div class="search-group-grid">${groups.categoryMatches.map(lib => createLibraryCard(lib)).join('')}</div>
                </div>`;
                navLinks.push({ id: 'search-categories', label: `Categories (${groups.categoryMatches.length})` });
            }
            
            if (groups.descriptionMatches.length > 0) {
                html += `<div class="search-group" id="search-descriptions">
                    <div class="search-group-header">Descriptions (${groups.descriptionMatches.length})</div>
                    <div class="search-group-grid">${groups.descriptionMatches.map(lib => createLibraryCard(lib)).join('')}</div>
                </div>`;
                navLinks.push({ id: 'search-descriptions', label: `Descriptions (${groups.descriptionMatches.length})` });
            }
            
            grid.innerHTML = html;
            
            // Generate and show navigation links
            updateSearchNavigation(navLinks);
        }
        
        // Update search navigation links
        function updateSearchNavigation(navLinks) {
            const searchNav = document.getElementById('searchNav');
            const searchNavLinks = document.getElementById('searchNavLinks');
            
            if (navLinks.length > 0) {
                // Generate navigation links
                const linksHtml = navLinks.map(link => 
                    `<a href="#${link.id}" class="search-nav-link" onclick="scrollToSearchSection('${link.id}')">${link.label}</a>`
                ).join('');
                
                searchNavLinks.innerHTML = linksHtml;
                searchNav.style.display = 'block';
            } else {
                searchNav.style.display = 'none';
            }
        }
        
        // Scroll to search section
        function scrollToSearchSection(sectionId) {
            const element = document.getElementById(sectionId);
            if (element) {
                // Use scrollIntoView with offset instead of manual calculation
                const searchContainer = document.querySelector('.search-container');
                const stickyHeight = searchContainer ? searchContainer.offsetHeight : 0;
                
                // First scroll to the element
                element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
                // Then adjust for the sticky header with a small delay
                setTimeout(() => {
                    const currentScroll = window.pageYOffset || document.documentElement.scrollTop;
                    const targetScroll = currentScroll - stickyHeight - 15; // 15px buffer
                    
                    window.scrollTo({
                        top: Math.max(0, targetScroll),
                        behavior: 'smooth'
                    });
                }, 100); // Small delay to let initial scroll start
            }
        }
        
        // Create a library card HTML
        function createLibraryCard(lib) {
            return `<div class="library-card" onclick="openLibraryDetail('${escapeHtml(lib.repository_name)}')">
                <div class="library-name">${escapeHtml(lib.name)}</div>
                <div class="library-version">v${escapeHtml(lib.version)}</div>
                <div class="library-author">${escapeHtml(lib.author)}</div>
                <div class="library-updated">Updated: ${formatDate(lib.github_updated_at || lib.processed_at)}</div>
                <div class="library-stars">* ${parseInt(lib.github_stars) || 0} stars</div>
                <div class="library-description">${escapeHtml(lib.sentence || lib.paragraph || 'No description available')}</div>
                <div class="library-category">${escapeHtml(lib.category)}</div>
            </div>`;
        }

        // Open library detail modal
        function openLibraryDetail(repositoryName) {
            const library = libraries.find(lib => lib.repository_name === repositoryName);
            if (!library) return;
            
            const modal = document.getElementById('modalOverlay');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            
            modalTitle.innerHTML = `
                <a href="${escapeHtml(library.repository_url)}" target="_blank" rel="noopener" style="color: inherit; text-decoration: none;">${escapeHtml(library.name)}</a>
                <button class="copy-name-btn" onclick="copyLibraryName('${escapeHtml(library.name)}')" title="Copy library name">⧉</button>
            `;
            
            // Get alphabetical neighbors
            const sortedLibraries = [...libraries].sort((a, b) => a.name.localeCompare(b.name));
            const currentIndex = sortedLibraries.findIndex(lib => lib.repository_name === repositoryName);
            const neighbors = getNeighbors(sortedLibraries, currentIndex);
            
            modalBody.innerHTML = `
                <div class="detail-section">
                    <div class="detail-label">Version</div>
                    <div class="detail-value">${escapeHtml(library.version)}</div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-label">Updated</div>
                    <div class="detail-value">${formatDate(library.github_updated_at || library.processed_at)}</div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-label">Author</div>
                    <div class="detail-value">
                        <a href="#" onclick="filterByAuthor('${escapeHtml(library.author)}'); closeModal(); return false;" 
                           style="color: #0066cc; text-decoration: underline; cursor: pointer;">
                            ${escapeHtml(library.author)}
                        </a>
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-label">Description</div>
                    <div class="detail-value">
                        ${escapeHtml(library.sentence || 'No description available')}
                        ${library.paragraph && library.paragraph.trim() !== (library.sentence || '').trim() ? `<br><br>${escapeHtml(library.paragraph)}` : ''}
                    </div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-label">Category</div>
                    <div class="detail-value">${escapeHtml(library.category)}</div>
                </div>
                
                <div class="detail-section">
                    <div class="detail-label">Supported Architectures</div>
                    <div class="detail-value">${escapeHtml(library.architectures)}</div>
                </div>
                
                ${library.depends ? `
                <div class="detail-section">
                    <div class="detail-label">Dependencies</div>
                    <div class="detail-value">${escapeHtml(library.depends)}</div>
                </div>
                ` : ''}
                
                <div class="detail-section">
                    <div class="detail-label">GitHub Repository</div>
                    <div class="detail-value">
                        <a href="${escapeHtml(library.repository_url)}" target="_blank" rel="noopener">
                            ${escapeHtml(library.repository_url)}
                        </a>
                    </div>
                </div>
                
                <div class="neighbors-section">
                    <div class="neighbors-title">Alphabetical Neighbors</div>
                    <div class="neighbors-grid">
                        ${neighbors.map(neighbor => `
                            <div class="neighbor-card ${neighbor.repository_name === repositoryName ? 'current' : ''}" 
                                 onclick="${neighbor.repository_name === repositoryName ? '' : `openLibraryDetail('${escapeHtml(neighbor.repository_name)}')`}">
                                <div class="neighbor-name">${escapeHtml(neighbor.name)}</div>
                                <div class="neighbor-author">${escapeHtml(neighbor.author)}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }

        // Get neighboring libraries in alphabetical order
        function getNeighbors(sortedLibraries, currentIndex) {
            const neighbors = [];
            const start = Math.max(0, currentIndex - 5);
            const end = Math.min(sortedLibraries.length, currentIndex + 6);
            
            for (let i = start; i < end; i++) {
                neighbors.push(sortedLibraries[i]);
            }
            
            return neighbors;
        }

        // Close modal functionality
        function closeModal() {
            const modal = document.getElementById('modalOverlay');
            modal.style.display = 'none';
            document.body.style.overflow = 'auto'; // Restore scrolling
        }

        // Copy library name to clipboard
        function copyLibraryName(libraryName) {
            navigator.clipboard.writeText(libraryName).then(() => {
                // Show feedback by temporarily changing the button
                const button = document.querySelector('.copy-name-btn');
                const originalText = button.textContent;
                button.textContent = '✓';
                button.style.color = '#28a745';
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.color = '';
                }, 1000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = libraryName;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
            });
        }

        // Search functionality
        function searchLibraries(query) {
            console.log('Search called with query:', query);
            currentSearchQuery = query;
            console.log('Current search query set to:', currentSearchQuery);
            
            // Show/hide clear search button
            const clearBtn = document.getElementById('clearSearchBtn');
            if (query.trim()) {
                clearBtn.style.display = 'block';
            } else {
                clearBtn.style.display = 'none';
            }
            
            applyFilters();
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Format date for display
        function formatDate(dateString) {
            if (!dateString) return 'Unknown';
            try {
                const date = new Date(dateString);
                const now = new Date();
                const diffTime = Math.abs(now - date);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                
                if (diffDays === 1) {
                    return '1 day ago';
                } else if (diffDays < 30) {
                    return `${diffDays} days ago`;
                } else if (diffDays < 365) {
                    const months = Math.floor(diffDays / 30);
                    return months === 1 ? '1 month ago' : `${months} months ago`;
                } else {
                    const years = Math.floor(diffDays / 365);
                    return years === 1 ? '1 year ago' : `${years} years ago`;
                }
            } catch (error) {
                return 'Unknown';
            }
        }

        // Set up event listeners
        document.getElementById('searchInput').addEventListener('input', (e) => {
            searchLibraries(e.target.value);
        });

        // Clear search button functionality
        document.getElementById('clearSearchBtn').addEventListener('click', () => {
            const searchInput = document.getElementById('searchInput');
            searchInput.value = '';
            searchLibraries('');
        });

        // Category section collapse/expand functionality
        document.getElementById('categoryHeader').addEventListener('click', () => {
            const header = document.getElementById('categoryHeader');
            const filterButtons = document.getElementById('filterButtons');
            
            if (filterButtons.classList.contains('collapsed')) {
                // Expand
                filterButtons.classList.remove('collapsed');
                header.classList.add('expanded');
            } else {
                // Collapse
                filterButtons.classList.add('collapsed');
                header.classList.remove('expanded');
            }
        });

        // About section collapse/expand functionality
        document.getElementById('aboutHeader').addEventListener('click', () => {
            const header = document.getElementById('aboutHeader');
            const aboutContent = document.getElementById('aboutContent');
            
            if (aboutContent.classList.contains('collapsed')) {
                // Expand
                aboutContent.classList.remove('collapsed');
                header.classList.add('expanded');
            } else {
                // Collapse
                aboutContent.classList.add('collapsed');
                header.classList.remove('expanded');
            }
        });

        // Platform section collapse/expand functionality
        document.getElementById('platformHeader').addEventListener('click', () => {
            const header = document.getElementById('platformHeader');
            const platformButtons = document.getElementById('platformButtons');
            
            if (platformButtons.classList.contains('collapsed')) {
                // Expand
                platformButtons.classList.remove('collapsed');
                header.classList.add('expanded');
            } else {
                // Collapse
                platformButtons.classList.add('collapsed');
                header.classList.remove('expanded');
            }
        });

        // Modal event listeners
        document.getElementById('modalClose').addEventListener('click', closeModal);
        document.getElementById('modalOverlay').addEventListener('click', (e) => {
            if (e.target === document.getElementById('modalOverlay')) {
                closeModal();
            }
        });
        
        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal();
            }
        });

        // Load libraries on page load
        loadLibraries();
    </script>
</body>
</html>
